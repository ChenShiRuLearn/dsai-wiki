# 使用马尔可夫生成对抗网络进行预先计算的实时纹理合成

![](http://upload-images.jianshu.io/upload_images/145616-fda62f92cbac5528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

*   文章地址：[《Precomputed Real-Time Texture Synthesis with Markovian Generative Adversarial Networks》](https://link.jianshu.com?t=https://arxiv.org/abs/1604.04382) arXiv.1604.04382

(转载请注明出处：[http://www.jianshu.com/p/6054799d7bb1](https://www.jianshu.com/p/6054799d7bb1) ，谢谢！)

* * *

# **Abstract**

本论文提出了[马尔可夫](https://link.jianshu.com?t=https://mqshen.gitbooks.io/prml/content/Chapter8/markov_random_fields.html)生成对抗网络(MGANs),一种训练能有效地进行纹理合成的生成神经网络的方法.当深度神经网络的方法最近已经在合成效果上展示出了显著成果的同时,它们依然带来了相当大的计算代价(低分辨率图片的运行分钟数).我们的论文处理了这个效率问题.比起之前的工作中使用大量的反卷积层,我们预计算了一个前馈的,步幅卷积(strided convolutional)网络,它对_马尔可夫碎片(Markovian patches)_的纹理数据进行捕获,并且可以直接生成任意维度的输出.这个网络可以直接把棕色噪声(brown noise)解码成逼真的纹理,或者把照片转化为艺术图像.通过对抗训练,我们得到的品质可以与最近的神经纹理合成方法相媲美.而且由于生成时不再需要优化,我们的运行时间的表现(0.25M pixel images at 25Hz)在很大的数量级上(至少快500倍)超越了之前的神经纹理合成器.我们将这个想法应用到纹理合成,风格转换,和视频风格化上.

**keywords：纹理合成，生成对抗网络**

# \*\*1.Introduction \*\*

图像合成是计算机图像和视觉上的一个经典问题.它关键的挑战在于要用简洁明了的方式捕获到复杂类型的图片的结构,可学习的模型,以及去找到一个有效的算法来学习这样的模型并且合成新的图像数据.大多数传统的_"纹理合成"_方法使用马尔可夫随机场的方法处理错综复杂的约束,而马尔可夫随机场是通过像素值的局部碎片区域描绘图像特征的。

最近,以深度神经网络为基础的生成模型已经在图像合成上展现了令人激动的新视点,深层结构对表现在物体类型(object classes)上的变化的捕获能力已经超过了像素水平上的方法.但是,至于能从有限的训练数据上到底能学到多少结构,仍然有很大的局限性.我们目前面临着两种主要的"深度"生成模型：**1) 全图像模型(full-image models)，生成整体图像；2)马尔可夫模型(Markovian models)，同样可以合成纹理**。

**第一种类型**,全图像模型,经常被设计成专门的训练好的自编码器.结果非常令人映象深刻但局限于细节上保真度有限的小图片(约64*64).**第二种类型**,深度马尔可夫模型,捕获了局部的数据并且把它们集合成高分辨率的图片.因此,有好的细节保真度,但是如果需要生成特殊的全局结构的话,还需要附加指引.我们的论文正是提出了深度马尔可夫纹理合成的第二种方法.

之前这种类型的神经学习方法是建立在一个反卷积网络结构上的.这自然得提供了碎片的混合以及得以再利用巨大的,有区别的训练好的神经网络比如VGG生成的错综复杂的,自然发生的多层次的纹理展现,再把它们用到图像合成上.说句题外话,我们不久会观察到这对于高质量的结果其实很关键.Gatys et al. 最先使用了这一方法,他用一个全局的高维特征向量的高斯模型来对碎片数据建模,而Li ey al.利用了神经网络激活层(neural activation),权衡了视觉与现实的扩展的局部碎片(patchs).

深度马尔可夫模型能够产生出色的视觉效果,尤其是比起传统的像素水平上的马尔可夫方法,不幸的是,反卷积方法所产生的运行时间代价仍然非常高,因为为了估计预图像(pre-image)的特征激活层(更高的网络层)需要迭代的反向传播.在大多数昂贵的建立MRF的高层特征碎片的情况下,一个高端的GPU也需要好几分钟来合成一个低分辨率的图像(512*512).

因此我们论文的目标就是要改善深度马尔可夫纹理合成的效率.关键思想在预计算网络的反向,这用一个步长的卷积网络(strided convolutional network)\[注:一个步长卷积网络因此用在训练过程中学习池化过程的子采样卷积过滤器代替了池化层(eg.双层均值池化和取样于一半分辨率的模糊的卷积核是等价的)\]来拟合网络的反向过程,单纯得在前馈模式中处理.尽管由固定大小的Patch训练,结果得到的网络可以在任意维上生成连续的(continuous)图像,而且不需要任何附加的优化和混合,就可以得到一个高质的针对特定风格并且表现很好的纹理生成器.

我们用对抗训练的方法训练了一个卷积网络,它可以维持和原图差不多的图像质量,高昂的优化方法.结果,我们获得了一个重大的提速:我们的GPU设备计算512*512的图片耗时在40ms内(nvidia titanX).关键的局限,当然,是为每一个纹理风格预计算前馈卷积网络.不必说,对于很多有潜力的应用,这仍然是一种有吸引力的平衡,比如说在艺术化图片或者是风格化视频方面.我们在实验中找到了一些相关的应用.

# **2.Related Work**

反卷积神经网络已经被介绍用于可视化深层特征和物体分类.............

.............

.............(待整理)

# **3.Model**

让我们首先概念性地说明提出这一方法的动机.基于方法\[Gatys, L.A(就是最原始的那篇论文 )., Ulyanov\]的数据显示,源(输入图片或者是噪声)和目标图片(纹理)的分布符合高斯模型(上图左1).一旦两分布匹配后它们不再有更好的改善.但是,现实世界中的数据并不总是遵守高斯分布的.比如,它可能会按照一个复杂的非线性复写(manifold).对抗训练可以识别出这样的复写以及它的识别网络(上图左2),并且在复写时用一个投影加强他生成的效能(power)(上图右2).我们用上下文关联的马尔可夫碎片(patches)改进了对抗训练(上图右1).这就允许了让学习专注于(focus on)绘制同一上下文的不同描述,而不是上下文和描述的混合.

图2:我们的模型包括了一个生成网络(蓝)和一个识别网络(绿),我们把识别网络应用于马尔可夫自然神经碎片上(紫区块作为识别网络的输入)

图2具现了我们的流程,它扩展了Li et al.的基于碎片的合成算法.我们首先连续的识别网络D(绿)代替了他们的碎片字典(包括迭代最邻近搜索),他学习从没有合适合成的特征碎片中辨别出真实的特征碎片(on VGG\_19 Relu3\_1,紫).第二个比较(D下方的流图)是同一张图片的VGG19编码,可以选用更高更抽象的Relu5_1层.如果我们运行VGG网络的反卷积,就会获取一个反卷积的图像合成器,我们称为_马尔可夫反卷积对抗网络_(MDANs).

MDANs仍然非常得慢,因此,我们将一个额外的生成网络G(蓝,步长卷各积网络)作为目标.他需要VGG\_19的Relu4\_1层的图像编码,并且直接把它解码为合成图片的像素.在整个训练期间我们不需要改变VGG19网络(灰),并且只需要优化D和G.重要的是,无论是D还是G都是为了最大化G的效果而同时训练的;D在这里作为G的对手.我们用_马尔可夫生成对抗网络(MGANs)表示了整个结构._

## **3.1 马尔可夫反卷积对抗网络(MDANs)**

我们的MDANs用一个由对抗训练驱动的反卷积过程合成图片:一个被训练于辨别从合成图像取样和的和示例图片取样的"神经碎片"识别网络D(绿).我们使用有规律地从`Vgg19`的`Relu3_1`层的输出的取样.对于每一个神经碎片它输出分类分数 `s=+1/-1`,来表示碎片有多"真"(s=1意味真).对于从每一个从合成图片取样的神经碎片,1-s就是它要最小化的纹理Loss.这个反卷积过程把这个损失反向传播到像素值上.跟Radford et al.一样我们使用批量正则化(`BN`)和Leaky ReLU(`LReLU`)来改进D的训练.

这里的si表示对于第i个神经碎片的分类得分(classifica score),并且N是O(x)中取样碎片的总数.这个对抗网络在运行中得到训练:它的参数是随机初始化的,并且之后在每次反卷积后被更新,因此它当合成结果改进的时候它也不断变得更加智能.

(1)式中附加的正则项r(x)是已有的使像素值更平滑的技术,使用Et和r(x)可以合成随机纹理(图3),通过最小化额外的内容损失Ec,网络可以生成上下文关联的与指示图片相关的合成图(图4).内容损失是在两特征图O(x)和 O(xc)之间的平均平方误 差(Mean Squared Error).我们把权值设为a1=1, a2=0.0001,并且式1使用ADAM方法计算反向传播(学习率0.02,动量值0.5).注意每个神经碎片 接收它自己的通过D的反向传播生成的梯度.为了在邻近的碎片间有一个合理的过渡,我们混合了他们的输出坡度,和纹理优化做的一样( Kwatra, V., Essa, I., Bobick, A., Kwatra, N.: Texture optimization for example-based synthesis. Siggraph 24(3), 795{802 (2005)).

图3:没有指导(Un-guided)纹理合成,使用MDANs.对每一例第一张图片是示例图片,其它两张是合成结果.

图4:指导过的(Guided)纹理合成,使用MDANs.使用的示例图片与图3一致

## \*\* 3.2 马尔可夫生成对抗网络(MGANs) **

MDANs 需要很多次的迭代并且要为每一个输出图片单独运行一次.我们现在训练一个可变的自动编码器(VAE variational auto-encoder)来直接把特征图谱解码为像素值.目标示例(纹理后的照片)是从MDANs中得到的.我们的生成器G(蓝,图2)需要 `VGG_19`的`Relu4_1`层作为输入,并且通过一个紧接着级联的步长很小的卷积层(FS Conv)的原始的卷积层来解码图片.尽管是由固定大小的输入训练的,这个生成器自然地扩展到了任意大小的图片. 正如Dosovitskiy el al.指出的,为训练一个自动编码器找到一个好的度量值是十分重要的:使用合成后图片和目标图片在像素水平上(图5,pixel VAE)的欧几里得距离生成了一个过于平滑的图片.与之相比神经编码水平改进了结果(图5,neural VAE),而且对抗训练更进一步地改善了对于目的风格的复刻(图5,MGANs) .

图5:我们的MGANs学习了从Vgg_19解码的输入图片到风格化后的示例(MDANs).MDANs的参考风格是毕加过索的"自画像1907".

我们的方法和经典的生成对抗网络(GANs)是相似的,主要的不同在于操作的不是全图,而是同一张图片的神经碎片.这样做利用了碎片间的上下文联系,并且 使得学习更加容易,更加有效,相比于学习一个物体类(objet class)的分布,或者是在上下文无关的数据间进行映射.  
　　另外地,我们也用一个最大的边缘标准(铰链损失Hinge Loss)代替了sigmoid函数和二进制交叉熵标准.这就避免了在学习D时消失的坡度.这在我们这里造成了更大的困难,比起Radfort el al.因为我们的训练数据中多样性更少.因此,sigmoid更容易饱和. 图5(MGANs)展示了训练来生成毕加索自画像风格的网络的结果.为了训练,我们随机挑选了75张来自CelebA数据集( Liu, Z., Luo, P., Wang, X., Tang, X.: Deep learning face attributes in the wild. In:ICCV (2015) )的人脸图片,额外又加上25张公共领域的非名人图片.  
　　我们改变了所有照片的大小因此最大的维度是384像素值.我们通过为每张照片生成9份不同旋转和 尺 寸的拷贝来扩大训练数据集.并且有规律地采样128*128的剪切图片的子窗口用作批量处理.总共我们就有了24,506份训练实例,每一个都作为一份训 练图片,它的(where)神经碎片取样自它的rely3_1层,并编码作为D的输入. 图5(MGANs)展示了我们的生成网络为一个训练照片的解码结果.最下面的一行展示的网络生成了好的测试数据.不必说,用G直接解码产生的很好的逼近.MDANs和MGANs主要的不同在于:MDANs更好地保护了输入图片的内容,而MGANs生成的结果更加风格化.这是因为MGANs是由很多图片训练的,因此学习了最常见的特征.另一个值得注意的不同是MDANs生成了更加自然的背景(比如有着平滑颜色的区域),这要归功于它迭代的改进.尽管有着这样的瑕疵,MGANs模型生成的可与之媲美的结果在速度上要快25,000倍.

图6 在训练MGANs的中间解码结果.

图 6展示了MGANs的一些中间结果.很清楚得看到训练更多时解码器效果越好.在处理过100批量(batch)后,这个网络已经可以学习到整体的颜色, 以及有明显对比度的区域.300批后,这个网络开始产生涂抹的描边(brush strokes)的纹理.1000批过后,它学会怎样画眼睛.更多的训练可以改进结果中的一些幽灵伪影(ghosting artifacts).注意模型对于测试集生成效果也好(右).

图7:可视化在生成网络中学习到的特征.

# **4 实验分析**

我们用我们的模型进行了实际的实验:我们研究了参数影响(分类层,批量大小(patch size))和模型的复杂性(网络的层数,每一层的通道数).然而可能不存在一个对于所有纹理通用的最适宜的设计,我们的研究阐明了模型在不同的情况下的行为.为了做公正的比较,我们采用的示例纹理图片的大小在实验中是固定的(128\*128),并且生成的合成图片都是256\*256的.

图8:在训练识别网络时的不同层和不同patch.

**可视化解码器的特征图：**我们具象化了在解码器G中学习的过滤器(图7).这些特征是直接从one-hot输入向量解码得到的.个体的patch是相似的,但是并没有准确地符合原图.不必说,这些人造图反应上的相似性对于合成新图应该是足够的.

**参数：**接下来,我们研究了改变识别网络的输入层的影响.为此我们在引导识别网络D时不使用VGG19的relu2\_1,relu3\_1作为输入.我们分别使用的大小为16,8,和4的patch,它们对地32像素的图片有相同的感受域(大约；忽略padding),图8的前三图展示了这样三个设置的结果.更低的层次(relu2\_1)生生的表现更为锐利(sharper),但是在损失纹理的结构和格式(form).更高的层次(relu4\_1)更好地保留了大颗粒的结构(比如说规律)但对于指引的前景(scenarios)却过于死板.relu3\_1在质量和弹性上提供了一个好的平衡.我们之后展示了patch大小的影响:我们将D的输入层固定为relu3\_1,并且用大小为16和4的patch和默认的8比较.图8的后两图展示了这样的改变同样可以影响到模型的严格程度(rigidty):更小的patch,弹性更好,而更大的patch更好地保留了结构.

**复杂性：**我们现在研究这些的影响:1)网络的层数；2)每一层的通道数.我们首先通过移除卷积层的方法改变D.这样做可以减少网络的深度并最终改变了合成图片的结果(图9,第一列).重新引入这个卷积层产生了更平滑的合成结果(图9,第2列).但是,在这些例子中,增加额外的层次并没有明显得改善图片的质量(图9,第3列).

图9:为训练识别网络采取的不同的深度.

用4,64,128的通道的卷积导来测试D,我们观察到通常来说减少通道数会带来更坏的结果(图9,每4列),但是在128和64个通道间并没有太大的差别.需求的复杂性同样依赖于实际上的纹理.比如说,"ivy"纹理是一个很简单的MRF,所以4通道和64通道的差别很微小,不像其他两个例子.

接下来,我们固定了识别网络,然后改变生成网络.我们注意到当从解码器中移除第一个卷积层时会带来质量上的损失,或者是有减小所有层的通道数目时,而且一个更复杂的设计只有极有限的改进.这可能是由于整个网络是由识别网络驱动的,而对于更好的改进的阻力表明在反卷积的过程中有一些重要的信息是一个前馈过程不能修复的.特别的,一点点步长的卷积层不能模拟最大池化层的非线性行为,因此经常产生另外的(alias)模式.这在相似的,纹理少的时候变得可见.为了减少失真并增加纹理的可变性,我们可以选择性得在输入图片中加入Perlin噪声.

**初始化：**通常来说,都是用随机值初始的网络.然而,我们发现D有着特定的生成能力.因此,为了用MDANs用同一种纹理转化不同的图片,一个之前训练的网络可以用来初始化.图10展示了用一个预训练的识别网络(已经转化过50张人脸的图片)初始化可以在50次迭代中产生更好的效果.与之相比,就算是经过了最开始的500次迭代,随机初始化也没有产生可以与之相比的结果.这对于用一个可以直接解码输入特征到原始输入图片的自编码器来初始化G是非常有用的.这样做可以基本上接近反转vgg_19的过程,并且使得整个对抗网络被更稳定得训练.

图10:对识别网络作不同的初始化.参考纹理是毕加索的自画像.

**VGG的角色：**我们同样确认了预训练网络VGG\_19的重要性.如图10的最后两张图展示的那样,从零开始训练识别网络的效果非常地不好.Ulyanov et al.同样观察到了这一点.我们的解释是,VGG\_19在为各种各样的图片生成可共享的特征图上有很大的统计上的作用(power),因此要比一个由有限张图片训练结果更接近人类视觉概念.

# 5.结果

这个部分展示了我们的MGANs合成的结果.我们用100张从ImageNet随机选择的图片来训练每一个模型,以及一张示例纹理.我们开始用MDANs模型产生了100张转化过的图片,然后定期地取样128*128的剪切图片作为MGASs的训练数据.对于每一个模型,我们一共有大约16k的采样.训练每次迭代需要12分钟.每次迭代最小的batch包括随机顺序后的所有sample.我们每个纹理迭代5次.

图11比较了我们的合成图片和之前方法的结果.首先,比使用全局数据的方法相比我们的方法有一个非常不同的特征:我们的方法转化纹理更为协调,比如说Lena的头发可以一致地映射到暗色的纹理. 相反,高斯模型在保持这样的一致性则比较失败,并且很难转化复杂的图片内容.....(总之讲了一下和其他方法的比较).

图12进一步得讨论了以高斯为基础的方法和我们的方法的不同.通常来说,它的结果更忠实的遵守了原始与风格相关的颜色分布,而且纹理背景更好,这是由于在学习中抒噪声映射到高斯分布上.另一方面,我们的方法产生更一致的纹理转化并且不需要承受一些复杂前景不满足高斯分布的状况.比如说在这两个例子中的建筑.与之相比,在复杂区域产生了更多或者更少的纹理.

图13展示了使用训练过的模型来解码噪声图,不指引的纹理合成也是有效的.在这种情况下,Perlin噪声图在VGG_19中向前计算并为解码器生成了特征图.让我们惊异的是,由随机Imagenet中的图片训练的模型可以将特征图解码成合理的纹理.这再一次展示了我们模型的泛化能力.最后,图13展示了我们的示视解码结果.作为一个前馈过程我们的方法不仅更快而且也相当程度上时间上比反卷积方法更为一致.

最后,我们提供了我们方法的 时间/内存占用 的细节.时间的计算是以标准基准框架为基础的(图15):我们的速度和Ulyanov的工作相同,他使用了前馈方法,比之间的反卷积方法要快更多.....(然后详细介绍了速度)... More precisely, both our method and Ulyanov et al. \[32\] are able to decode 512-by-512 images at 25Hz (Figure 15,left), while \[32\] leads the race by a very small margin. The time cost of both methods scale linearly with the number of pixels in the image. For example,our method cost 10 ms for a 256-by-256 image, 40 ms for a 512-by-512 image, and 160 ms for a 1024-by-1024 image. Both methods show a very signicant improvement in speed over previous deconvolutional methods such as Gatys et al. \[8\] and Li et al. \[21\] (Figure 15 right): about 500 times faster than Gatys et al. \[8\], and 5000 times faster than Li et al. \[21\]. In the meantime our method is also faster than most traditional pixel based texture synthesizers (which rely on expensive nearest-neighbor searching). A possible exceptions would be a GPU implementation of \\Patch Match" \[1\], which could run at comparable speed.However, it provides the quality bene ts (better blending, invariance) of a deep-neural-network method.

...(和内存占用)...

Memory-wise, our generative model takes 70 Mb memory for its parameters(including the VGG network till layer Relu4_1). At runtime, the required memory to decode a image linearly depends on the image's size: for a 256-by-256 picture it takes about 600 Mb, and for a 512-by-512 picture it requires about 2.5 Gb memory. Notice memory usage can be reduced by subdividing the input photo into blocks and run the decoding in a scanline fashion. However, we do not further explore the optimization of memory usage in this paper.

# 6.局限

我们现在的方法在非纹理数据上表现的不好.比如说,它不能在两张不同面部照片间转化面部特征.这是因为面部特征不能看做纹理,并且需要语义上的理解(比如说表情,姿势和性别).一个可能的解决方案是把我们的模型和学习物体识别结合起来(couple) 这样本地的数据就可以被更好得被制约(conditioned).为了合生更有照片真实感的纹理,Li et al.可以获得更好的效果要归功于它没有参数化(non-sampling)的抽样可以防止数据走样.我们的方法可变形的纹理上做得更好,并且快很多.

我们的模型有一个和以高斯为基础的方法更不同的特征.通过对全局特征分布的捕捉,这些其他的方法可以更好保留那些示例图片全局上的"形状和感受".相反,我们的方法可能偏离了示例纹理,比如说,全局的颜色分布.然而,这样的偏离可能不总是坏的比如说当内容图需要占一个重要的角色时.

因为我们的模型学习了同一张内容的映射时的不同叙述,它需要特征上很不相同的特征.因为这个原因我们使用了VGG_19.这使得我们的方法在解决很稳定的背景(天空,没有聚焦的区域)时显得很弱.我们观察,从大多数数据来看,在区域上生成更好的纹理的方法在内容上经较弱,而我们的方法在包含可识别的特征的区域上做得很好.我们相信这对于未来结合这两种方法的长处是有价值的.

# 7 结论

这篇论文最关键的见识在于对抗生成网络可以被用马尔可夫方法应用并且学习怎么用同一内容到不同叙述的映射.我们创造了个同一张纹理图和随机从ImageNet中选取的图片训练的生成网络.一旦被训练,我们的模型可以将棕色噪声解码成现实纹理,或者是把照片解码成画作.我们展示了我们的模型在给复杂的图片内容保留一致的纹理的一些优点.一旦训练(每个例子大概占用我们一小时的时间),合成会变得很快并且在风格转化上有很好的不变性.

我们的方法在学习生成模型上只是一小步,但是在未来工作的路上,可能是在更多的数据上学习更宽阔的框架,不仅是马尔可夫模型,也同样包括大颗粒规模的结构模型.这额外的在图片布局上的不变性可能,作为一个副作用,开启了用更多训练数据训练马尔可夫模型之路,因此允许了更复杂在更多的类型上有更好的生成兼容性的解码器.终极目标可能是直接解码,在真实世界的图片上对于大分类有生产力的图片模型.

（文中部分地方由于某些原因没有完全翻译，以后再补上，不好意思！）
